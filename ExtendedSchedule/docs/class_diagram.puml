@startuml class_diagram

namespace domain {
    namespace entity {
        class Lesson <<Entity>> {
            +ID string
            +Title string
            +Type LessonType
            +Position int
            +Teacher TeacherInfo
            +Groups []GroupInfo
        }

        enum LessonType {
            Lecture
            Practice
            Seminar
            Exam
        }

        Lesson o-- LessonType
        Lesson "1" o-- "1" TeacherInfo
        Lesson "1" o-- "1..M" GroupInfo

        class ExcludedLesson <<Entity>> {
            +ID uuid.UUID
            +LessonID string
            +Position int
            +WeekDay int
            +Teacher *TeacherInfo
        }

        ExcludedLesson "1" o-- "1" TeacherInfo

        class GroupInfo <<Entity>> {
            +ID string
            +Name string
        }

        class TeacherInfo <<Entity>> {
            +ID string
            +Name string
        }
    }

    namespace aggregate {
        class UserConfig <<Aggregate>> {
            +UserID uuid.UUID
            +JoinedGroups []GroupInfo
            +ExcludedLessons []ExcludedLesson
            +AddGroup(group GroupInfo)
            +AddExcluded(lesson []ExcludedLesson)
        }

        class DaySchedule <<Aggregate>> {
            +Date time.Time
            +Lessons []Lesson
            +Join(other DaySchedule)
            +Exclude(lessons []entity.ExcludedLesson)
        }

        DaySchedule "M" o-- domain.entity.Lesson
    }

    domain.aggregate.UserConfig "M" o-- "1" domain.entity.ExcludedLesson
    domain.aggregate.UserConfig "M" o-- "1" domain.entity.GroupInfo

    namespace repository {
        interface IUserConfigRepository {
            +Get(userID uuid.UUID) UserConfig
            +Update(userID, desired UserConfig)
        }

        IUserConfigRepository --> domain.aggregate.UserConfig
    }

    namespace provider {
        interface IBaseScheduleProvider {
            +GetByGroup(groupID string, ..options) []DaySchedule
            +GetByLesson(groupID string, lessonID string, ..options) []DaySchedule
        }

        IBaseScheduleProvider --r-> domain.aggregate.DaySchedule
    }

    namespace builder {
        interface IUserScheduleBuilder {
            +Make(userID uuid.UUID, start time.Time, end time.Time) []DaySchedule
        }

        IUserScheduleBuilder --> domain.aggregate.DaySchedule

        IUserScheduleBuilder ..> domain.repository.IUserConfigRepository
        IUserScheduleBuilder ..> domain.provider.IBaseScheduleProvider
    }
}

namespace service {
    namespace userconfig {
        interface IService {
            +Get(userID uuid.UUID) UserConfig
            +Update(userID uuid.UUID, desired UserConfig)
        }

        class service implements IService {
            -userConfig IUserConfigRepository
        }

        service "1" o-- "1" domain.repository.IUserConfigRepository
    }

    namespace schedule {
        interface IService {
            +Get(userID uuid.UUID, ..options)
        }

        class service implements IService {
            -schedulBuilder IUserScheduleBuilder
        }

        service "1" o-- "1" domain.builder.IUserScheduleBuilder
    }
}

@enduml