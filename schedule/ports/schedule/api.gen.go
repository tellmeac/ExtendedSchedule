// Package schedule provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package schedule

import (
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/gin-gonic/gin"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Day defines model for Day.
type Day struct {
	Date openapi_types.Date `json:"date"`

	// Ascending ordered lessons by position
	Lessons []Lesson `json:"lessons"`
}

// Faculty defines model for Faculty.
type Faculty struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

// Lesson defines model for Lesson.
type Lesson struct {
	// Study group codes
	Groups []string `json:"groups"`
	ID     string   `json:"id"`
	Kind   string   `json:"kind"`
	Name   string   `json:"name"`

	// Position
	Pos     float32     `json:"pos"`
	Teacher interface{} `json:"teacher"`
}

// LessonWithoutContext defines model for LessonWithoutContext.
type LessonWithoutContext struct {
	// Study group codes
	Groups  []string    `json:"groups"`
	ID      string      `json:"id"`
	Kind    string      `json:"kind"`
	Name    string      `json:"name"`
	Teacher interface{} `json:"teacher"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	// ascending ordered schedule days
	Days      []Day              `json:"days"`
	EndDate   openapi_types.Date `json:"endDate"`
	StartDate openapi_types.Date `json:"startDate"`
}

// StudyGroup defines model for StudyGroup.
type StudyGroup struct {
	Faculty Faculty `json:"faculty"`
	ID      string  `json:"id"`
	Name    string  `json:"name"`
}

// Teacher defines model for Teacher.
type Teacher struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLessonsByGroupIdParams defines parameters for GetLessonsByGroupId.
type GetLessonsByGroupIdParams struct {
	From openapi_types.Date `form:"from" json:"from"`
	To   openapi_types.Date `form:"to" json:"to"`
}

// GetScheduleByGroupIdParams defines parameters for GetScheduleByGroupId.
type GetScheduleByGroupIdParams struct {
	From openapi_types.Date `form:"from" json:"from"`
	To   openapi_types.Date `form:"to" json:"to"`
}

// GetScheduleByTeacherIdParams defines parameters for GetScheduleByTeacherId.
type GetScheduleByTeacherIdParams struct {
	From openapi_types.Date `form:"from" json:"from"`
	To   openapi_types.Date `form:"to" json:"to"`
}

// GetTeachersParams defines parameters for GetTeachers.
type GetTeachersParams struct {
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUsersScheduleParams defines parameters for GetUsersSchedule.
type GetUsersScheduleParams struct {
	Email openapi_types.Email `form:"email" json:"email"`
	From  openapi_types.Date  `form:"from" json:"from"`
	To    openapi_types.Date  `form:"to" json:"to"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get groups
	// (GET /groups)
	GetGroups(c *gin.Context, params GetGroupsParams)
	// Get group's lesson list that occurs in passed period
	// (GET /lessons/byGroup/{id})
	GetLessonsByGroupId(c *gin.Context, id string, params GetLessonsByGroupIdParams)
	// Get group's schedule
	// (GET /schedule/byGroup/{id})
	GetScheduleByGroupId(c *gin.Context, id string, params GetScheduleByGroupIdParams)
	// Get teacher's schedule
	// (GET /schedule/byTeacher/{id})
	GetScheduleByTeacherId(c *gin.Context, id string, params GetScheduleByTeacherIdParams)
	// Get teachers
	// (GET /teachers)
	GetTeachers(c *gin.Context, params GetTeachersParams)
	// Get personal schedule
	// (GET /users/schedule)
	GetUsersSchedule(c *gin.Context, params GetUsersScheduleParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// GetGroups operation middleware
func (siw *ServerInterfaceWrapper) GetGroups(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupsParams

	// ------------- Optional query parameter "filter" -------------
	if paramValue := c.Query("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "filter", c.Request.URL.Query(), &params.Filter)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter filter: %s", err)})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := c.Query("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter limit: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetGroups(c, params)
}

// GetLessonsByGroupId operation middleware
func (siw *ServerInterfaceWrapper) GetLessonsByGroupId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter id: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLessonsByGroupIdParams

	// ------------- Required query parameter "from" -------------
	if paramValue := c.Query("from"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument from is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", c.Request.URL.Query(), &params.From)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter from: %s", err)})
		return
	}

	// ------------- Required query parameter "to" -------------
	if paramValue := c.Query("to"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument to is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "to", c.Request.URL.Query(), &params.To)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter to: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetLessonsByGroupId(c, id, params)
}

// GetScheduleByGroupId operation middleware
func (siw *ServerInterfaceWrapper) GetScheduleByGroupId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter id: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScheduleByGroupIdParams

	// ------------- Required query parameter "from" -------------
	if paramValue := c.Query("from"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument from is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", c.Request.URL.Query(), &params.From)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter from: %s", err)})
		return
	}

	// ------------- Required query parameter "to" -------------
	if paramValue := c.Query("to"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument to is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "to", c.Request.URL.Query(), &params.To)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter to: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetScheduleByGroupId(c, id, params)
}

// GetScheduleByTeacherId operation middleware
func (siw *ServerInterfaceWrapper) GetScheduleByTeacherId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter id: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScheduleByTeacherIdParams

	// ------------- Required query parameter "from" -------------
	if paramValue := c.Query("from"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument from is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", c.Request.URL.Query(), &params.From)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter from: %s", err)})
		return
	}

	// ------------- Required query parameter "to" -------------
	if paramValue := c.Query("to"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument to is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "to", c.Request.URL.Query(), &params.To)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter to: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetScheduleByTeacherId(c, id, params)
}

// GetTeachers operation middleware
func (siw *ServerInterfaceWrapper) GetTeachers(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeachersParams

	// ------------- Optional query parameter "filter" -------------
	if paramValue := c.Query("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "filter", c.Request.URL.Query(), &params.Filter)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter filter: %s", err)})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := c.Query("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter limit: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetTeachers(c, params)
}

// GetUsersSchedule operation middleware
func (siw *ServerInterfaceWrapper) GetUsersSchedule(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersScheduleParams

	// ------------- Required query parameter "email" -------------
	if paramValue := c.Query("email"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument email is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "email", c.Request.URL.Query(), &params.Email)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter email: %s", err)})
		return
	}

	// ------------- Required query parameter "from" -------------
	if paramValue := c.Query("from"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument from is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", c.Request.URL.Query(), &params.From)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter from: %s", err)})
		return
	}

	// ------------- Required query parameter "to" -------------
	if paramValue := c.Query("to"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument to is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "to", c.Request.URL.Query(), &params.To)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter to: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetUsersSchedule(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/groups", wrapper.GetGroups)

	router.GET(options.BaseURL+"/lessons/byGroup/:id", wrapper.GetLessonsByGroupId)

	router.GET(options.BaseURL+"/schedule/byGroup/:id", wrapper.GetScheduleByGroupId)

	router.GET(options.BaseURL+"/schedule/byTeacher/:id", wrapper.GetScheduleByTeacherId)

	router.GET(options.BaseURL+"/teachers", wrapper.GetTeachers)

	router.GET(options.BaseURL+"/users/schedule", wrapper.GetUsersSchedule)

	return router
}
